Z <- abs(Z)
Z <- ifelse(Y, Z, -Z)
Sigma <- cov(Z)
B <- sapply(
seq_len(data$J),
function(x) coef(bayesglm(Y[, x] ~ X, family = binomial(link = "probit")))
)
B <- t(B)
B_raw <- B * sqrt(diag(Sigma))
mu <- apply(B_raw, 2, mean)
sigma <- pmin(99, apply(B_raw, 2, sd))
Tau <- solve(Sigma)
list(Tau = Tau, Z = Z, B_raw = B_raw, mu = mu, sigma = sigma)
}
data <- list(
Y = subset(data, select = -env),
X = cbind(1, scale(poly(data$env, 2))),
covx = cov(cbind(1, scale(poly(data$env, 2)))),
K = 3,
J = ncol(data) - 1,
n = nrow(data),
I = diag(ncol(data) - 1),
df = ncol(data)
)
model <- jags(
data,
function() inits(data), c("B", "Rho", "EnvRho","Tau"), jsdm_jags(),
n.chains = 15, n.iter = 2e5, n.adapt = 25e5, n.thin = 100,
parallel = TRUE, DIC = FALSE
)
save(
model,
file = paste0("models/model-", format(Sys.time(), "%Y-%m-%d-%H-%M-%S"), ".rda")
)
model
}
predict_y_jsdm <- function(x, ns = 1000) {
data   <- if(x$parallel) x$model[[1]]$data() else x$model$data()
n      <- data$n
nsp    <- data$J
n.samples  <- x$mcmc.info$n.samples
B <- x$sims.list$B
X <- data$X
Y <- data$Y
inprod_mat <- cppFunction(
"NumericMatrix inprod_mat(NumericMatrix X, NumericMatrix B) {
int nX = X.nrow();
int nB = B.nrow();
int nK = X.ncol();
NumericMatrix theta(nX, nB);
for (int i = 0; i < nX; i++) {
for (int j = 0; j < nB; j++) {
theta(i, j) = 0;
for (int k = 0; k < nK; k++) {
theta(i, j) += X(i, k) * B(j, k);
}
}
}
return(theta);
}"
)
vapply(
floor(seq(1, n.samples, length.out = ns)),
function(x) inprod_mat(X, B[x, ,]),
matrix(NA_real_, n, nsp)
)
}
prob_cooccur_es <- function(Y) {
K <- ncol(Y)
ans <- matrix(0, K, K)
for (k in 1:K) {
for (kk in 1:K) {
N1 <- sum(Y[, k])
N2 <- sum(Y[, kk])
N <- nrow(Y)
j <- max(0, N1 + N2 - N):min(N1, N2)
p <- vector("numeric", length(j))
for (i in seq_along(j)) {
p[i] <- (
choose(N, j[i]) * choose(N - j[i], N2 - j[i]) *
choose(N - N2, N1 - j[i])
) / (
choose(N, N2) * choose(N, N1)
)
}
ans[k, kk] <- (sum(Y[, k] + Y[, kk] == 2) - sum(p * j)) / N
}
}
ans
}
mean_correlations <- do.call(
rbind,
lapply(
seq_along(models),
function(i) {
x <- models[[i]]
nm <- strsplit(
names(models)[[i]], "(?<=[a-z])(?=[A-Z])", perl = TRUE
)[[1]]
nsp <- ncol(x$mean$Rho)
ut <- upper.tri(x$mean$Rho)
sp <- arrayInd(which(ut), c(nsp, nsp))
ans <- data.frame(
model = i,
sp1 = sp[, 1],
sp2 = sp[, 2],
rho = c(prob_cooccur_es(x$model$cluster1$data()$Y)[ut], x$mean$Rho[ut]),
rho_type = rep(c("Effect-Size", "Residual"), each = sum(ut)),
sgn = sign(x$mean$Rho)[ut],
significant = x$overlap$Rho[ut],
cint = simulation_parameters$comp_inter[[i]][ut],
fint = simulation_parameters$fac_inter[[i]][ut],
density = tail(nm, 2)[1],
type = paste0(head(nm, -2), collapse = ""),
nsp = nsp,
stringsAsFactors = FALSE
)
ans$cint[is.na(ans$cint)] <- 0
ans$fint[is.na(ans$fint)] <- 0
ans$density[ans$density == "Even"] <- "None"
ans$density <- factor(ans$density, c("None", "Sparse", "Dense"))
ans$type[ans$type == "Env"] <- "Environmental\nFiltering Only"
ans$type[ans$type == "Fac"] <- "Facilitation"
ans$type[ans$type == "Comp"] <- "Competition"
ans$type[ans$type == "FacComp"] <- "Facililation +\nCompetition"
ans$type <- factor(
ans$type,
c(
"Environmental\nFiltering Only", "Facilitation", "Competition",
"Facililation +\nCompetition"
)
)
ans$interaction <- "None"
ans$interaction <- ifelse(ans$cint, "Competition", ans$interaction)
ans$interaction <- ifelse(ans$fint, "Facilitation", ans$interaction)
ans$status <- ifelse(
ans$significant,
ifelse(ans$sgn * -ans$cint == 1 | ans$sgn * ans$fint == 1, "TP", "FP"),
ifelse(ans$cint == 0 & ans$fint == 0, "TN", "FN")
)
ans$interaction <- factor(
ans$interaction, c("None", "Facilitation", "Competition")
)
ans
}
)
)
sim_data<-readRDS("sim_data.rds")
setwd("~/Documents/GitHub/Ecology-models/simcoms-master")
sim_data<-readRDS("sim_data.rds")
m_e5<-run_model(sim_data$EnvEvenSp5,run_model)
m_e5<-run_model(sim_data$EnvEvenSp5)
run_model <- function(data) {
jsdm_jags <- function() {
model.file <- tempfile()
cat(
"model {
for (i in 1:n) {
Z[i, 1:J] ~ dmnorm(Mu[i, ], Tau)
for (j in 1:J) {
Mu[i, j] <- inprod(B_raw[j, ], X[i, ])
Y[i, j] ~ dbern(step(Z[i, j]))
}
}
for (j in 1:J) {
sigma_[j] <- sqrt(Sigma[j, j])
env_sigma_[j] <- sqrt(EnvSigma[j, j])
for (k in 1:K) {
B_raw[j, k] ~ dnorm(mu[k], tau[k])
B[j, k] <- B_raw[j, k] / sigma_[j]
}
for (j_ in 1:J) {
Rho[j, j_] <- Sigma[j, j_] / (sigma_[j] * sigma_[j_])
EnvRho[j, j_] <- EnvSigma[j, j_] / (env_sigma_[j] * env_sigma_[j_])
EnvSigma[j, j_] <- sum(EnvSigma1[, j, j_]) + sum(EnvSigma2[, , j, j_])
for (k in 2:K) {
EnvSigma1[k - 1, j, j_] <- B[j, k] * B[j_, k]
for (k_ in 2:K) {
EnvSigma2[k - 1, k_ - 1, j, j_] <-
B[j, k] * B[j_, k_] * ifelse(k_ != k, covx[k, k_], 0)
}
}
}
}
for (k in 1:K) {
mu[k] ~ dnorm(0, 1)
tau[k] <- pow(sigma[k], -2)
sigma[k] ~ dnorm(0, 1)T(0,)
}
Tau ~ dwish(I, df)
Sigma <- inverse(Tau)
}",
file = model.file
)
model.file
}
inits <- function(data) {
Y <- as.matrix(data$Y)
X <- as.matrix(data$X)[, -1]
Tau <- rWishart(1, data$df, data$I)[, , 1]
Sigma <- solve(Tau)
Z <- rep(0, data$J)
Z <- mvrnorm(1, Z, Sigma)
Z <- replicate(data$n, Z)
Z <- t(Z)
Z <- abs(Z)
Z <- ifelse(Y, Z, -Z)
Sigma <- cov(Z)
B <- sapply(
seq_len(data$J),
function(x) coef(bayesglm(Y[, x] ~ X, family = binomial(link = "probit")))
)
B <- t(B)
B_raw <- B * sqrt(diag(Sigma))
mu <- apply(B_raw, 2, mean)
sigma <- pmin(99, apply(B_raw, 2, sd))
Tau <- solve(Sigma)
list(Tau = Tau, Z = Z, B_raw = B_raw, mu = mu, sigma = sigma)
}
data <- list(
Y = subset(data, select = -env),
X = cbind(1, scale(poly(data$env, 2))),
covx = cov(cbind(1, scale(poly(data$env, 2)))),
K = 3,
J = ncol(data) - 1,
n = nrow(data),
I = diag(ncol(data) - 1),
df = ncol(data)
)
model <- jags(
data,
function() inits(data), c("B", "Rho", "EnvRho","Tau"), jsdm_jags(),
n.chains = 5, n.iter = 2e5, n.adapt = 25e5, n.thin = 100,
parallel = TRUE, DIC = FALSE
)
save(
model,
file = paste0("models/model-", format(Sys.time(), "%Y-%m-%d-%H-%M-%S"), ".rda")
)
model
}
m_e5<-run_model(sim_data$EnvEvenSp5)
.expandSigmaChains(snames, sgibbs, otherpar, simIndex=simIndex,
sigErrGibbs, kgibbs, REDUCT)
sigma<-invsigma<-array(NA,dim=c(ns,ns,ng))
sgibbs<-mod_gjam_low$chains$sgibbs
sigErrGibbs<-mod_gjam_low$chains$sigErrGibbs
kgibbs<-mod_gjam_low$chains$kgibbs
N<-mod_gjam_low$modelList$reductList$N
r<-mod_gjam_low$modelList$reductList$r
for(j in 1:ng){
Z  <- matrix(sgibbs[j,],N,r)
sigma[,,j] <- .expandSigma(sigErrGibbs[j], ns, Z = Z, kgibbs[j,], REDUCT = T) #sigma
invsigma[,,j] <- invWbyRcpp(sigErrGibbs[j], Z[kgibbs[j,],]) #inverse sigma
}
library(gjam)
library(coda)
library(fitR)
library(ggmcmc)
#to recreate sigma
Rcpp::sourceCpp('~/Tesi/Code/modified_gjam/Gjam/src/cppFns.cpp')
source("~/Tesi/Code/modified_gjam/Gjam/R/gjamHfunctions_mod.R")
setwd("~/Tesi/Code/Ecology-models-master_1/simcoms-master")
# lapply(list.files(path = "."),load,.GlobalEnv)
#setwd("~/Tesi/Code/Ecology-models-master/simcoms-master")
load("params.rds")
load("sim_names.rds")
load("comp_inter.rds")
load("fac_inter.rds")
sim_data<-readRDS("sim_data.rds")
ng <- 10000
burnin <- 1000
data_10<- sim_data$EnvEvenSp10
ns<-10
ydata<-data_10[,-11]
xdata<-scale(poly(data_10$env, 2))
r<-3
rl <-list(N=ns-1, r=r)
ml  <- list(ng = ng, burnin = burnin, typeNames = 'PA',reductList=rl)
colnames(xdata)<- c("env","env2")
formula<- ~env + env2
mod_gjam_low <- gjam(formula, xdata, ydata, modelList = ml)
## to set thininhg - choose by =..
ind<-seq(1,dim(mod_gjam_low$chains$sgibbs)[1], by=1)
gjam_mc<- mcmc(mod_gjam_low$chains$sgibbs[ind,]) #thinned sigma
s2s1<- mcmc(mod_gjam_low$chains$sgibbs[ind,2]) #s2s1 chain
ind_d<-vector()
ind_d[1]<-1
for (i in 1:9) ind_d[i+1]<- ind_d[i]+ns-i+1
gjam_mc_nd<- mcmc(mod_gjam_low$chains$sgibbs[ind,-ind_d]) #thinned sigma non diagonal elements
#acf
#acfplot(gjam_mc)  ##autocor plot
ggs_autocorrelation(ggs(gjam_mc)) ###autocr
#traceplots
x11()
plot(gjam_mc) #traceplots
#cumuplot
cumuplot(s2s1)
x11()
cumuplot(gjam_mc)
\
me5$sims.list$B
dim(me5$sims.list$B)
mfs5 <- load_object("model-jsdm-Tau-2019-05-06-20-54-53.rda")
#mfs5 <- load_object("model-2019-04-13-17-51-16.rda")
summary(mfs5)
#mfs5$Rhat
jsdm_conv(mfs5)
mfs5$mcmc.info[1:7]
j_metric_facSparse5<-metrics_jsdm(mfs5,fac = fac_inter[[7]],only_env = F)
# cat("Success rate ")
# j_metric_facSparse5$success_env
# j_metric_facSparse5$success_fac
# cat("\n")
cat(sprintf("Success rate for non-interacting: %s\n", round(j_metric_facSparse5$success_env,3)))
cat(sprintf("Success rate for facilitation: %s\n", round(j_metric_facSparse5$success_fac,3)))
######################################################Prepare data
data<-sim_data$FacSparseSp5
data <- list(
Y = subset(data, select = -env),
X = cbind(1, scale(poly(data$env, 2))),
covx = cov(cbind(1, scale(poly(data$env, 2)))),
K = 3,
J = ncol(data) - 1,
n = nrow(data),
I = diag(ncol(data) - 1),
df = ncol(data)
)
#Tau_n<-to_prec(mfd10$mean$Tau)
#plot_cor_jsdm(mfs5,data$Y,fac_inter[[7]])
mod_list_Rho<-list()
mod_list_Rho<-list(jsdm =mfs5$mean$Rho*(!mfs5$overlap0$Rho))
mod_list_Tau<-list()
mod_list_Tau<-list(jsdm =mfs5$mean$Rho*(!mfs5$overlap0$Rho))
pred_j<-pnorm(predict_y_jsdm(mfs5))
pred_j_mean <- apply(pred_j, 1:2, mean)
pred_j_05 <- apply(pred_j, 1:2, quantile,0.05)
pred_j_95 <- apply(pred_j, 1:2, quantile,0.95)
pred_jsdm<-list(pred_j_mean=pred_j_mean,pred_j_05=pred_j_05,pred_j_95=pred_j_95)
t<-predict_y_jsdm(mfs5)
k<- apply(pred_j, c(1,2), mean)
plot(sim_data$FacDenseSp5[,6],k[,1])
plot(sim_data$CompDenseSp5[,6], pred_j_mean[.1])
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
dev.off()
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
mfs5 <- load_object("model-jsdm-Tau-2019-05-06-20-54-53.rda")
#mfs5 <- load_object("model-2019-04-13-17-51-16.rda")
summary(mfs5)
#mfs5$Rhat
jsdm_conv(mfs5)
mfs5$mcmc.info[1:7]
pred_j<-pnorm(predict_y_jsdm(mfs5))
pred_j_mean <- apply(pred_j, 1:2, mean)
pred_j_05 <- apply(pred_j, 1:2, quantile,0.05)
pred_j_95 <- apply(pred_j, 1:2, quantile,0.95)
pred_jsdm<-list(pred_j_mean=pred_j_mean,pred_j_05=pred_j_05,pred_j_95=pred_j_95)
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
me10 <- load_object("model-2019-04-10-08-26-20.rda")
summary(me10)
jsdm_conv(me10)
me10$mcmc.info[1:7]
j_metric_e10<-metrics_jsdm(me10)
cat("Success rate ")
j_metric_e10$success_env
data<-sim_data$EnvEvenSp10
data <- list(
Y = subset(data, select = -env),
X = cbind(1, scale(poly(data$env, 2))),
covx = cov(cbind(1, scale(poly(data$env, 2)))),
K = 3,
J = ncol(data) - 1,
n = nrow(data),
I = diag(ncol(data) - 1),
df = ncol(data)
)
##########################################################################################
#Tau<-solve
#Tau_n<-to_prec(me10$mean$Tau)
#Tau_k<-Tau_n*(!(model$q97.5$Tau>0 & model$q2.5$Tau<0))
plot_cor_jsdm<-function(mod,y,interact=diag(ncol(y))){
par(mfrow=c(2,4),oma = c(3, 1, 2, 1))
corrplot(cor(y), diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("Correlation cor(Y)")
corrplot(mod$mean$EnvRho, diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("EnvRho")
corrplot(mod$mean$EnvRho*(!mod$overlap0$EnvRho), diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("EnvRho signif")
corrplot(mod$mean$Rho, diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("Rho")
corrplot(mod$mean$Rho*(!mod$overlap0$Rho), diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("Rho signif")
corrplot(interact, diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("True interactions")
}
#plot_cor_jsdm(me10,data$Y)
###Correlation
mod_list_Rho<-list()
mod_list_Rho<-list(jsdm =me10$mean$Rho*(!me10$overlap0$Rho))
mod_list_Tau<-list()
mod_list_Tau<-list(jsdm =me10$mean$Rho*(!me10$overlap0$Rho))
##Prediction
pred_j<-pnorm(predict_y_jsdm(me10))
pred_j_mean <- apply(pred_j, 1:2, mean)
pred_j_05 <- apply(pred_j, 1:2, quantile,0.05)
pred_j_95 <- apply(pred_j, 1:2, quantile,0.95)
pred_jsdm<-list(pred_j_mean=pred_j_mean,pred_j_05=pred_j_05,pred_j_95=pred_j_95)
plot(sim_data$CompDenseSp5[,6], pred_j_mean[,1])
#load("model-2019-04-10-15-13-15.rda")
mfs5 <- load_object("model-jsdm-Tau-2019-05-06-20-54-53.rda")
#mfs5 <- load_object("model-2019-04-13-17-51-16.rda")
summary(mfs5)
#mfs5$Rhat
jsdm_conv(mfs5)
mfs5$mcmc.info[1:7]
j_metric_facSparse5<-metrics_jsdm(mfs5,fac = fac_inter[[7]],only_env = F)
# cat("Success rate ")
# j_metric_facSparse5$success_env
# j_metric_facSparse5$success_fac
# cat("\n")
cat(sprintf("Success rate for non-interacting: %s\n", round(j_metric_facSparse5$success_env,3)))
cat(sprintf("Success rate for facilitation: %s\n", round(j_metric_facSparse5$success_fac,3)))
######################################################Prepare data
data<-sim_data$FacSparseSp5
data <- list(
Y = subset(data, select = -env),
X = cbind(1, scale(poly(data$env, 2))),
covx = cov(cbind(1, scale(poly(data$env, 2)))),
K = 3,
J = ncol(data) - 1,
n = nrow(data),
I = diag(ncol(data) - 1),
df = ncol(data)
)
#Tau_n<-to_prec(mfd10$mean$Tau)
#plot_cor_jsdm(mfs5,data$Y,fac_inter[[7]])
mod_list_Rho<-list()
mod_list_Rho<-list(jsdm =mfs5$mean$Rho*(!mfs5$overlap0$Rho))
mod_list_Tau<-list()
mod_list_Tau<-list(jsdm =mfs5$mean$Rho*(!mfs5$overlap0$Rho))
pred_j<-pnorm(predict_y_jsdm(mfs5))
pred_j_mean <- apply(pred_j, 1:2, mean)
pred_j_05 <- apply(pred_j, 1:2, quantile,0.05)
pred_j_95 <- apply(pred_j, 1:2, quantile,0.95)
pred_jsdm<-list(pred_j_mean=pred_j_mean,pred_j_05=pred_j_05,pred_j_95=pred_j_95)
data$X
crossprod(data$X,mfs5$mean$B)
mfs5$mean$B
crossprod(data$X,t(mfs5$mean$B))
t(mfs5$mean$B)
data$X
crossprod(data$X,t(mfs5$mean$B))
data$X%*%t(mfs5$mean$B)
yp<-data$X%*%t(mfs5$mean$B)
plot(data$X[,2],yp[,1])
plot(data$X[,2],yp[,2])
me10 <- load_object("model-2019-04-10-08-26-20.rda")
summary(me10)
jsdm_conv(me10)
me10$mcmc.info[1:7]
j_metric_e10<-metrics_jsdm(me10)
cat("Success rate ")
j_metric_e10$success_env
data<-sim_data$EnvEvenSp10
data <- list(
Y = subset(data, select = -env),
X = cbind(1, scale(poly(data$env, 2))),
covx = cov(cbind(1, scale(poly(data$env, 2)))),
K = 3,
J = ncol(data) - 1,
n = nrow(data),
I = diag(ncol(data) - 1),
df = ncol(data)
)
##########################################################################################
#Tau<-solve
#Tau_n<-to_prec(me10$mean$Tau)
#Tau_k<-Tau_n*(!(model$q97.5$Tau>0 & model$q2.5$Tau<0))
plot_cor_jsdm<-function(mod,y,interact=diag(ncol(y))){
par(mfrow=c(2,4),oma = c(3, 1, 2, 1))
corrplot(cor(y), diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("Correlation cor(Y)")
corrplot(mod$mean$EnvRho, diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("EnvRho")
corrplot(mod$mean$EnvRho*(!mod$overlap0$EnvRho), diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("EnvRho signif")
corrplot(mod$mean$Rho, diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("Rho")
corrplot(mod$mean$Rho*(!mod$overlap0$Rho), diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("Rho signif")
corrplot(interact, diag = FALSE, order = "original",tl.pos = "ld", tl.cex = 0.5, method = "color",col=cols(200), type = "lower")
title("True interactions")
}
#plot_cor_jsdm(me10,data$Y)
###Correlation
mod_list_Rho<-list()
mod_list_Rho<-list(jsdm =me10$mean$Rho*(!me10$overlap0$Rho))
mod_list_Tau<-list()
mod_list_Tau<-list(jsdm =me10$mean$Rho*(!me10$overlap0$Rho))
##Prediction
pred_j<-pnorm(predict_y_jsdm(me10))
pred_j_mean <- apply(pred_j, 1:2, mean)
pred_j_05 <- apply(pred_j, 1:2, quantile,0.05)
pred_j_95 <- apply(pred_j, 1:2, quantile,0.95)
pred_jsdm<-list(pred_j_mean=pred_j_mean,pred_j_05=pred_j_05,pred_j_95=pred_j_95)
yp<-data$X%*%t(me10$mean$B)
plot(data$X[,2],yp[,1])
plot(data$X[,2],pnorm(yp[,1]))
